[1mdiff --git a/pruebas/parser b/pruebas/parser[m
[1mdeleted file mode 100755[m
[1mindex a63a988..0000000[m
Binary files a/pruebas/parser and /dev/null differ
[1mdiff --git a/pruebas/parser.c b/pruebas/parser.c[m
[1mdeleted file mode 100644[m
[1mindex d64be64..0000000[m
[1m--- a/pruebas/parser.c[m
[1m+++ /dev/null[m
[36m@@ -1,122 +0,0 @@[m
[31m-#include <stdlib.h>[m
[31m-#include <string.h>[m
[31m-#include <stdio.h>[m
[31m-[m
[31m-typedef enum Method {UNSUPPORTED, GET, POST} Method;[m
[31m-[m
[31m-typedef struct Header {[m
[31m-	char *name;[m
[31m-	char *value;[m
[31m-	struct Header *next;[m
[31m-} Header;[m
[31m-[m
[31m-typedef struct Request {[m
[31m-	enum Method method;[m
[31m-	char *url;[m
[31m-	struct Header *headers;[m
[31m-} Request;[m
[31m-[m
[31m-struct Request *parse_request(const char *raw);[m
[31m-[m
[31m-struct Request[m
[31m-*parse_request(const char *raw)[m
[31m-{[m
[31m-	struct Request *req = NULL;[m
[31m-	req = malloc(sizeof(struct Request));[m
[31m-	memset(req, 0, sizeof(struct Request));[m
[31m-[m
[31m-	// Method[m
[31m-    	size_t meth_len = strcspn(raw, " ");[m
[31m-[m
[31m-	if (meth_len != 3 || meth_len != 4) {[m
[31m-		printf("Falta un espacio entre el m√©todo y la ruta.\n");[m
[31m-		exit(1);[m
[31m-	}[m
[31m-[m
[31m-[m
[31m-    	if (memcmp(raw, "GET", strlen("GET")) == 0) {[m
[31m-        	req->method = GET;[m
[31m-    	} else if (memcmp(raw, "POST", strlen("POST")) == 0) {[m
[31m-        	req->method = POST;[m
[31m-    	} else {[m
[31m-        	req->method = UNSUPPORTED;[m
[31m-    	}[m
[31m-[m
[31m-    	raw += meth_len + 1; // move past <SP>[m
[31m-[m
[31m-    	// Request-URI[m
[31m-    	size_t url_len = strcspn(raw, " ");[m
[31m-    	req->url = malloc(url_len + 1);[m
[31m-    	if (!req->url) {[m
[31m-        	return NULL;[m
[31m-    	}[m
[31m-    	memcpy(req->url, raw, url_len);[m
[31m-    	req->url[url_len] = '\0';[m
[31m-    	[m
[31m-	if (raw[url_len] != ' ') {[m
[31m-		printf("Falta un espacio entre la ruta y la versi√≥n.\n");[m
[31m-		exit(1);[m
[31m-	}[m
[31m-[m
[31m-	raw += url_len + 1; // move past <SP>[m
[31m-[m
[31m-    	// raw += ver_len + 2; // move past <CR><LF>[m
[31m-[m
[31m-    	struct Header *header = NULL, *last = NULL;[m
[31m-    	while (raw[0]!='\r' || raw[1]!='\n') {[m
[31m-        	last = header;[m
[31m-        	header = malloc(sizeof(Header));[m
[31m-        	if (!header) {[m
[31m-            		return NULL;[m
[31m-        	}[m
[31m-[m
[31m-        	// name[m
[31m-        size_t name_len = strcspn(raw, ":");[m
[31m-        header->name = malloc(name_len + 1);[m
[31m-        if (!header->name) {[m
[31m-            return NULL;[m
[31m-        }[m
[31m-        memcpy(header->name, raw, name_len);[m
[31m-        header->name[name_len] = '\0';[m
[31m-        raw += name_len + 1; // move past :[m
[31m-        while (*raw == ' ') {[m
[31m-            raw++;[m
[31m-        }[m
[31m-[m
[31m-        // value[m
[31m-        size_t value_len = strcspn(raw, "\r\n");[m
[31m-        header->value = malloc(value_len + 1);[m
[31m-        if (!header->value) {[m
[31m-            return NULL;[m
[31m-        }[m
[31m-        memcpy(header->value, raw, value_len);[m
[31m-        header->value[value_len] = '\0';[m
[31m-        raw += value_len + 2; // move past <CR><LF>[m
[31m-[m
[31m-        // next[m
[31m-        header->next = last;[m
[31m-    }[m
[31m-    req->headers = header;[m
[31m-    raw += 2; // move past <CR><LF>[m
[31m-[m
[31m-[m
[31m-    return req;[m
[31m-}[m
[31m-[m
[31m-int main(void) {[m
[31m-    char *raw_request = "GET / HTTP/1.1\r\n"[m
[31m-            "Host: localhost:8080\r\n"[m
[31m-            "\r\n";[m
[31m-[m
[31m-    struct Request *req = parse_request(raw_request);[m
[31m-    if (req) {[m
[31m-        printf("Method: %d\n", req->method);[m
[31m-        printf("Request-URI: %s\n", req->url);[m
[31m-        puts("Headers:");[m
[31m-        struct Header *h;[m
[31m-        for (h=req->headers; h; h=h->next) {[m
[31m-            printf("%32s: %s\n", h->name, h->value);[m
[31m-        }[m
[31m-    }[m
[31m-    return 0;[m
[31m-}[m
[1mdiff --git a/pruebas/regex b/pruebas/regex[m
[1mdeleted file mode 100755[m
[1mindex 05b462a..0000000[m
Binary files a/pruebas/regex and /dev/null differ
[1mdiff --git a/pruebas/regex.c b/pruebas/regex.c[m
[1mdeleted file mode 100644[m
[1mindex e880c53..0000000[m
[1m--- a/pruebas/regex.c[m
[1m+++ /dev/null[m
[36m@@ -1,37 +0,0 @@[m
[31m-#include <stdio.h>[m
[31m-#include <stdlib.h>[m
[31m-#include <regex.h>[m
[31m-[m
[31m-int[m
[31m-main(void)[m
[31m-{[m
[31m-	int match;[m
[31m-	int err;[m
[31m-	regex_t preg;[m
[31m-	regmatch_t pmatch[6];[m
[31m-	size_t nmatch = 6;[m
[31m-	const char *str_request = "GET /index.html HTTP/1.1\r\n";[m
[31m-	const char *str_regex = "^([GET|POST]+)(\\s+)(/.*)(\\s+)(HTTP/1.1\r\n)";[m
[31m-	err = regcomp(&preg, str_regex, REG_EXTENDED);[m
[31m-	if (err == 0) {[m
[31m-		match = regexec(&preg, str_request, nmatch, pmatch, 0);[m
[31m-		nmatch = preg.re_nsub;[m
[31m-		regfree(&preg);[m
[31m-		[m
[31m-		if (match == 0) {[m
[31m-			printf("\"%.*s\"\n", pmatch[1].rm_eo - pmatch[1].rm_so,[m
[31m-					      &str_request[pmatch[1].rm_so]);[m
[31m-			printf("\"%.*s\"\n", pmatch[2].rm_eo - pmatch[2].rm_so,[m
[31m-					      &str_request[pmatch[2].rm_so]);[m
[31m-			printf("\"%.*s\"\n", pmatch[3].rm_eo - pmatch[3].rm_so,[m
[31m-					      &str_request[pmatch[3].rm_so]);[m
[31m-			printf("\"%.*s\"\n", pmatch[4].rm_eo - pmatch[4].rm_so,[m
[31m-					      &str_request[pmatch[4].rm_so]);[m
[31m- 			printf("\"%.*s\"\n", pmatch[5].rm_eo - pmatch[5].rm_so,[m
[31m-					      &str_request[pmatch[5].rm_so]);[m
[31m-		} else if (match == REG_NOMATCH) {[m
[31m-			printf("unmatch\n");[m
[31m-		}[m
[31m-	}[m
[31m-	return 0;[m
[31m-}[m
[1mdiff --git a/run.sh b/run.sh[m
[1mindex 61d8bc5..6047c06 100755[m
[1m--- a/run.sh[m
[1m+++ b/run.sh[m
[36m@@ -1,8 +1,5 @@[m
 #!/bin/bash[m
 [m
[31m-rm webserver.log[m
[31m-rm web_sstt[m
[31m-pkill -9 web_sstt[m
 gcc -o web_sstt web_sstt.c[m
 echo "[LOG] Iniciando servidor web en el puerto 8080."[m
 ./web_sstt 8080 .[m
[1mdiff --git a/web_sstt.c b/web_sstt.c[m
[1mindex 271d2e7..cac93c3 100644[m
[1m--- a/web_sstt.c[m
[1m+++ b/web_sstt.c[m
[36m@@ -208,8 +208,30 @@[m [mstruct Request[m
  * @return 0 si est√° bien formada; 1 si no[m
  */[m
 int[m
[31m-check_bad_request(const char *request)[m
[32m+[m[32mcheck_bad_request(char *request)[m
 {[m
[32m+[m[32m    /* Flag para indicar si la petici√≥n est√° bien formada o no. */[m
[32m+[m[32m    int mal_formada = 0;[m
[32m+[m
[32m+[m[32m    /* Obtenemos la primera l√≠nea de la petici√≥n ('GET / HTTP/1.1') */[m
[32m+[m[32m    size_t len = strcspn(request, "\r");[m
[32m+[m
[32m+[m[32m    char primera_linea[len];[m
[32m+[m[32m    char otras[strlen(request) - len];[m
[32m+[m
[32m+[m[32m    primera_linea[len] = '\0';[m
[32m+[m[32m    otras[strlen(request) - len] = '\0';[m
[32m+[m
[32m+[m[32m    memcpy(primera_linea, request, len);[m
[32m+[m[32m    memcpy(otras, request + len, strlen(request) - len);[m
[32m+[m
[32m+[m[32m    char *lineas[10]; // ¬øQu√© tama√±o tiene que tener esto?[m
[32m+[m[32m    int i = 0;[m
[32m+[m[32m    lineas[i] = strtok(otras, "\r\n");[m
[32m+[m[32m    while (lineas[i] != NULL)[m
[32m+[m[32m        lineas[++i] = strtok(NULL, "\r\n");[m
[32m+[m
[32m+[m[32m    /* */[m[41m    [m
 	int match, err;[m
 	regex_t preg;[m
 	regmatch_t pmatch[6];[m
[36m@@ -219,22 +241,36 @@[m [mcheck_bad_request(const char *request)[m
 	err = regcomp(&preg, str_regex, REG_EXTENDED);[m
 [m
 	if (err == 0) {[m
[31m-		match = regexec(&preg, request, nmatch, pmatch, 0);[m
[32m+[m		[32mmatch = regexec(&preg, primera_linea, nmatch, pmatch, 0);[m
 		nmatch = preg.re_nsub;[m
 		regfree(&preg);[m
 		[m
[31m-		if (match == 0) 		        return 0;[m
[31m-		else if (match == REG_NOMATCH)	return 1;[m
[32m+[m		[32mif (match == REG_NOMATCH)	mal_formada = 1;[m
 	}	[m
[32m+[m
[32m+[m[32m    regmatch_t pmatch2[5];[m
[32m+[m[32m    nmatch = 5;[m
[32m+[m[32m    const char *other_headers_regex = "^([A-Za-z]+)(:)(\\s+)([A-Za-z]+)";[m
[32m+[m[32m    int j = 0;[m
[32m+[m
[32m+[m[32m    err = regcomp(&preg, other_headers_regex, REG_EXTENDED);[m
[32m+[m
[32m+[m[32m    if (err == 0) {[m
[32m+[m[32m        while (lineas[j] != NULL) {[m
[32m+[m[32m            match = regexec(&preg, lineas[j], nmatch, pmatch2, 0);[m
[32m+[m[32m            nmatch = preg.re_nsub;[m
[32m+[m[32m            regfree(&preg);[m
[32m+[m
[32m+[m[32m            if (match == REG_NOMATCH) mal_formada = 1;[m[41m  [m
[32m+[m[32m            j++;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return mal_formada;[m
 }[m
 [m
 void [m
 response(int fd_form, int status_code, int fd, char *filetype)[m
 {[m
[31m-	// 'fd_form' ser√° NULL SIEMPRE que 'status_code'[m
[31m-	// sea distinto de 200. En ese caso, 'fd_form' ser√° el descriptor[m
[31m-	// del fichero correspondiente.[m
[31m-[m
 	char response[BUFSIZE];[m
 	char date[DATE_SIZE];[m
 	int index;[m
[36m@@ -352,15 +388,10 @@[m [mprocess_web_request(int descriptorFichero)[m
          * entre el m√©todo y la ruta solicitada, si existe un espacio entre la ruta y[m
          * la versi√≥n de HTTP, etc.[m
          */[m
[31m-        size_t len = strcspn(buffer, "\r");[m
[31m-        char header[len];[m
[31m-        header[len] = '\0';[m
[31m-        memcpy(header, buffer, len);[m
[31m-[m
         int ret;[m
[31m-        if ((ret = check_bad_request(header)) == 1)[m
[32m+[m[32m        if ((ret = check_bad_request(buffer)) == 1)[m
             response(NOFILE, BADREQUEST, descriptorFichero, "text/html");[m
[31m-        [m
[32m+[m
 		// Parsear la petici√≥n para obtener el m√©todo y el[m
 		// path del archivo que se est√° pidiendo[m
 		struct Request *req = parse_request(buffer);[m
